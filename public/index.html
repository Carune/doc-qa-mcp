<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Doc QA MCP Demo</title>
    <style>
      :root {
        --bg-a: #0a2236;
        --bg-b: #16354d;
        --surface: #f8f6f1;
        --surface-soft: #efece4;
        --ink: #14212b;
        --ink-soft: #5c6c79;
        --line: #c8d2d9;
        --primary: #d9480f;
        --secondary: #0f766e;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        color: var(--ink);
        font-family: "Noto Sans KR", "Malgun Gothic", "Segoe UI", sans-serif;
        background:
          radial-gradient(1000px 500px at 0% 0%, #1c4f72, transparent 65%),
          linear-gradient(135deg, var(--bg-a), var(--bg-b));
        padding: 16px;
      }

      .shell {
        width: min(1200px, 100%);
        margin: 0 auto;
        background: var(--surface);
        border: 1px solid #0b1620;
        border-radius: 14px;
        overflow: hidden;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.28);
      }

      .head {
        padding: 18px;
        border-bottom: 1px solid var(--line);
        background: linear-gradient(120deg, #faf8f2, #f6f3eb);
      }

      .head h1 {
        margin: 0;
        font-size: 26px;
      }

      .head p {
        margin: 8px 0 0;
        color: var(--ink-soft);
        font-size: 14px;
      }

      .layout {
        display: grid;
        grid-template-columns: 380px 1fr;
        min-height: 72vh;
      }

      .left {
        background: var(--surface-soft);
        border-right: 1px solid var(--line);
        padding: 14px;
      }

      .right {
        padding: 14px;
        min-width: 0;
      }

      .card {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: #fff;
        padding: 12px;
      }

      .card + .card {
        margin-top: 10px;
      }

      .card h2 {
        margin: 0 0 8px;
        font-size: 16px;
      }

      .hint {
        margin: 0 0 8px;
        color: var(--ink-soft);
        font-size: 12px;
      }

      textarea,
      input[type="text"],
      input[type="number"],
      input[type="file"] {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #fff;
        font: inherit;
        padding: 9px 10px;
      }

      textarea {
        min-height: 86px;
        resize: vertical;
      }

      .row {
        margin-top: 8px;
        display: grid;
        grid-template-columns: 1fr 110px;
        gap: 8px;
      }

      .actions {
        margin-top: 10px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      button {
        border: 1px solid #111827;
        border-radius: 10px;
        padding: 8px 12px;
        font-weight: 700;
        cursor: pointer;
        background: var(--primary);
        color: #fff;
      }

      button.alt {
        background: var(--secondary);
      }

      button.ghost {
        background: #fff;
        color: var(--ink);
      }

      button:disabled {
        opacity: 0.6;
        cursor: wait;
      }

      .status {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #fff;
        padding: 10px 12px;
        margin-bottom: 10px;
        font-size: 13px;
      }

      .status.ok {
        border-color: #99f6e4;
        background: #f0fdfa;
      }

      .status.warn {
        border-color: #fde68a;
        background: #fffbeb;
      }

      .status.bad {
        border-color: #fecaca;
        background: #fef2f2;
      }

      .result-head {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      .result-head h2 {
        margin: 0;
        font-size: 18px;
      }

      .chips {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }

      .chip {
        border: 1px solid #cbd5e1;
        border-radius: 999px;
        background: #f8fafc;
        padding: 3px 8px;
        font-size: 11px;
      }

      .answer {
        margin: 10px 0 0;
        border: 1px solid #dbe4ea;
        border-radius: 12px;
        background: #fcfdfd;
        color: #0f172a;
        padding: 12px;
        line-height: 1.55;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .list {
        margin-top: 10px;
        display: grid;
        gap: 8px;
      }

      .item {
        border: 1px solid #dbe4ea;
        border-radius: 10px;
        background: #fff;
        padding: 10px;
      }

      .item .head {
        margin: 0 0 6px;
        padding: 0;
        border: 0;
        background: transparent;
        font-family: Consolas, "JetBrains Mono", monospace;
        font-size: 12px;
        color: #334155;
        word-break: break-all;
      }

      .item .body {
        margin: 0;
        white-space: pre-wrap;
        line-height: 1.45;
        word-break: break-word;
      }

      details {
        margin-top: 12px;
      }

      pre.raw {
        margin: 8px 0 0;
        max-height: 280px;
        overflow: auto;
        border: 1px solid #1e293b;
        border-radius: 10px;
        background: #0f172a;
        color: #e2e8f0;
        padding: 10px;
        font-size: 12px;
        white-space: pre-wrap;
        word-break: break-word;
      }

      @media (max-width: 980px) {
        .layout {
          grid-template-columns: 1fr;
        }

        .left {
          border-right: 0;
          border-bottom: 1px solid var(--line);
        }
      }
    </style>
  </head>
  <body>
    <main class="shell">
      <header class="head">
        <h1>Document QA MCP Demo</h1>
        <p>문서 인덱싱, 검색, 답변 생성을 한 화면에서 테스트합니다.</p>
      </header>

      <section class="layout">
        <aside class="left">
          <div class="card">
            <h2>1) 경로 인덱싱</h2>
            <p class="hint">줄바꿈으로 여러 파일 경로를 입력하세요. 지원: .md, .txt, .pdf</p>
            <textarea id="paths" placeholder="예: docs/my-manual.md"></textarea>
            <div class="actions">
              <button id="indexBtn">경로 인덱싱</button>
              <button id="sourcesBtn" class="alt">소스 목록</button>
              <button id="samplePathsBtn" class="ghost">샘플 채우기</button>
            </div>
          </div>

          <div class="card">
            <h2>2) 파일 업로드 인덱싱</h2>
            <p class="hint">.md/.txt/.pdf 파일을 직접 올려 인덱싱합니다.</p>
            <input id="files" type="file" multiple accept=".md,.txt,.pdf,text/markdown,text/plain,application/pdf" />
            <div class="actions">
              <button id="uploadIndexBtn" class="alt">업로드 + 인덱싱</button>
            </div>
          </div>

          <div class="card">
            <h2>3) 질의 실행</h2>
            <p class="hint">Ask는 일반 Q&A, 전체 요약은 인덱싱된 청크를 넓게 모아 요약합니다.</p>
            <input id="question" type="text" placeholder="질문을 입력하세요" />
            <div class="actions">
              <button id="askBtn">Ask</button>
              <button id="summarizeBtn" class="alt">전체 요약</button>
              <button id="askJsonBtn" class="alt">Ask (JSON)</button>
              <button id="searchBtn" class="ghost">Search Only</button>
            </div>
          </div>

          <div class="card">
            <h2>4) 운영 도구</h2>
            <div class="actions">
              <button id="storageBtn" class="ghost">저장소 정보</button>
              <button id="resetBtn" class="ghost">인덱스 초기화</button>
              <button id="clearBtn" class="ghost">화면 초기화</button>
            </div>
          </div>
        </aside>

        <section class="right">
          <div id="status" class="status">준비됨. 인덱싱 후 질문하세요.</div>

          <div class="result-head">
            <h2 id="resultTitle">결과</h2>
            <div id="chips" class="chips"></div>
          </div>

          <pre id="answer" class="answer">아직 결과가 없습니다.</pre>
          <div id="items" class="list"></div>

          <details>
            <summary>원본 JSON 보기</summary>
            <pre id="rawJson" class="raw">{}</pre>
          </details>
        </section>
      </section>
    </main>

    <script>
      const el = {
        paths: document.getElementById("paths"),
        files: document.getElementById("files"),
        question: document.getElementById("question"),
        indexBtn: document.getElementById("indexBtn"),
        sourcesBtn: document.getElementById("sourcesBtn"),
        samplePathsBtn: document.getElementById("samplePathsBtn"),
        uploadIndexBtn: document.getElementById("uploadIndexBtn"),
        askBtn: document.getElementById("askBtn"),
        summarizeBtn: document.getElementById("summarizeBtn"),
        askJsonBtn: document.getElementById("askJsonBtn"),
        searchBtn: document.getElementById("searchBtn"),
        storageBtn: document.getElementById("storageBtn"),
        resetBtn: document.getElementById("resetBtn"),
        clearBtn: document.getElementById("clearBtn"),
        status: document.getElementById("status"),
        resultTitle: document.getElementById("resultTitle"),
        chips: document.getElementById("chips"),
        answer: document.getElementById("answer"),
        items: document.getElementById("items"),
        rawJson: document.getElementById("rawJson"),
      };

      function setStatus(text, tone = "ok") {
        el.status.textContent = text;
        el.status.className = `status ${tone}`;
      }

      function resetOutput() {
        el.resultTitle.textContent = "결과";
        el.chips.innerHTML = "";
        el.answer.textContent = "아직 결과가 없습니다.";
        el.items.innerHTML = "";
        el.rawJson.textContent = "{}";
      }

      function appendChip(label, value) {
        const node = document.createElement("span");
        node.className = "chip";
        node.textContent = `${label}: ${value}`;
        el.chips.appendChild(node);
      }

      function renderItems(items) {
        el.items.innerHTML = "";
        for (const item of items) {
          const article = document.createElement("article");
          article.className = "item";

          const head = document.createElement("p");
          head.className = "head";
          head.textContent = item.head;

          const body = document.createElement("p");
          body.className = "body";
          body.textContent = item.body;

          article.appendChild(head);
          article.appendChild(body);
          el.items.appendChild(article);
        }
      }

      async function callApi(path, method, body) {
        const response = await fetch(path, {
          method,
          headers: { "Content-Type": "application/json" },
          body: body ? JSON.stringify(body) : undefined,
        });

        const text = await response.text();
        let data = text;
        try {
          data = JSON.parse(text);
        } catch {}

        if (!response.ok) {
          throw new Error(typeof data === "string" ? data : JSON.stringify(data));
        }

        return data;
      }

      async function callAskStream(payload, handlers) {
        const response = await fetch("/api/ask-stream", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!response.ok) {
          throw new Error(await response.text());
        }
        if (!response.body) {
          throw new Error("Empty stream body");
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          while (true) {
            const eventEnd = buffer.indexOf("\n\n");
            if (eventEnd < 0) break;

            const rawEvent = buffer.slice(0, eventEnd);
            buffer = buffer.slice(eventEnd + 2);

            const parsed = parseSseEvent(rawEvent);
            if (!parsed) continue;

            if (parsed.event === "meta") handlers.onMeta?.(parsed.data);
            if (parsed.event === "token") handlers.onToken?.(parsed.data);
            if (parsed.event === "done") handlers.onDone?.(parsed.data);
            if (parsed.event === "error") handlers.onError?.(parsed.data);
          }
        }
      }

      function parseSseEvent(rawEvent) {
        const lines = rawEvent.split("\n");
        let event = "";
        const dataLines = [];

        for (const line of lines) {
          if (line.startsWith("event:")) event = line.slice(6).trim();
          if (line.startsWith("data:")) dataLines.push(line.slice(5).trim());
        }

        if (!event) return null;

        const rawData = dataLines.join("\n");
        if (!rawData) return { event, data: null };

        try {
          return { event, data: JSON.parse(rawData) };
        } catch {
          return { event, data: rawData };
        }
      }

      async function withLoading(button, label, action) {
        const origin = button.textContent;
        button.disabled = true;
        button.textContent = label;
        try {
          await action();
        } finally {
          button.disabled = false;
          button.textContent = origin;
        }
      }

      function renderAskResult(data, title = "답변 결과") {
        const citations = Array.isArray(data.citations) ? data.citations : [];
        el.resultTitle.textContent = title;
        el.chips.innerHTML = "";
        appendChip("answer mode", data.answer_generation_mode || "-");
        appendChip("retrieval", data.retrieval_mode || "-");
        appendChip("latency", `${data.latency_ms || 0} ms`);
        appendChip("citations", citations.length);

        el.answer.textContent = data.answer || "답변 없음";
        if (data.guidance) {
          el.answer.textContent += `\n\n[안내] ${data.guidance}`;
        }

        renderItems(
          citations.map((c, idx) => ({
            head: `[${idx + 1}] ${c.source} #${c.chunk_index} (score=${c.score})`,
            body: c.snippet || "",
          })),
        );

        el.rawJson.textContent = JSON.stringify(data, null, 2);
      }

      function renderIndexResult(data) {
        el.resultTitle.textContent = "인덱싱 결과";
        el.chips.innerHTML = "";
        appendChip("indexed", data.indexed_count ?? 0);
        appendChip("chunks", data.chunk_count ?? 0);
        appendChip("embedding", data.embedding_enabled ? "on" : "off");
        appendChip("failed", Array.isArray(data.failed) ? data.failed.length : 0);

        el.answer.textContent = "인덱싱 처리가 완료되었습니다.";
        renderItems(
          (data.failed || []).map((f) => ({ head: f.path || "unknown", body: f.reason || "" })),
        );

        el.rawJson.textContent = JSON.stringify(data, null, 2);
      }

      function renderSourcesResult(data) {
        const sources = Array.isArray(data.sources) ? data.sources : [];
        el.resultTitle.textContent = "소스 목록";
        el.chips.innerHTML = "";
        appendChip("count", sources.length);

        el.answer.textContent =
          sources.length > 0 ? "현재 인덱싱된 문서 목록입니다." : "인덱싱된 문서가 없습니다.";

        renderItems(
          sources.map((s) => ({
            head: `${s.path} (${s.chunkCount} chunks)`,
            body: `indexedAt: ${s.indexedAt}`,
          })),
        );

        el.rawJson.textContent = JSON.stringify(data, null, 2);
      }

      function renderSearchResult(data) {
        const hits = Array.isArray(data.hits) ? data.hits : [];
        el.resultTitle.textContent = "검색 결과";
        el.chips.innerHTML = "";
        appendChip("retrieval", data.retrieval_mode || "-");
        appendChip("hits", hits.length);

        el.answer.textContent = hits.length > 0 ? "근거 청크입니다." : "검색 결과가 없습니다.";
        if (data.guidance) {
          el.answer.textContent += `\n\n[안내] ${data.guidance}`;
        }

        renderItems(
          hits.map((h, idx) => ({
            head: `[${idx + 1}] ${h.source} #${h.chunk_index} (score=${h.score})`,
            body: h.snippet || "",
          })),
        );

        el.rawJson.textContent = JSON.stringify(data, null, 2);
      }

      function renderStorageResult(data) {
        el.resultTitle.textContent = "저장소 정보";
        el.chips.innerHTML = "";
        appendChip("persisted", data.persisted ? "true" : "false");

        if (!data.persisted || !data.storage) {
          el.answer.textContent = "현재는 비영속 모드입니다.";
          renderItems([]);
          el.rawJson.textContent = JSON.stringify(data, null, 2);
          return;
        }

        const s = data.storage;
        appendChip("size", `${s.size_bytes} bytes`);
        appendChip("max", `${s.max_bytes} bytes`);
        appendChip("utilization", `${Math.round((s.utilization_ratio || 0) * 100)}%`);

        el.answer.textContent = "인메모리 인덱스 파일 상태입니다.";
        renderItems([
          {
            head: s.path,
            body: `exists=${s.exists}, format_version=${s.format_version}`,
          },
        ]);
        el.rawJson.textContent = JSON.stringify(data, null, 2);
      }

      function renderError(error) {
        el.resultTitle.textContent = "오류";
        el.chips.innerHTML = "";
        el.answer.textContent = String(error);
        el.items.innerHTML = "";
        el.rawJson.textContent = String(error);
      }

      function arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        const chunkSize = 0x8000;
        let binary = "";

        for (let i = 0; i < bytes.length; i += chunkSize) {
          const chunk = bytes.subarray(i, i + chunkSize);
          binary += String.fromCharCode(...chunk);
        }

        return btoa(binary);
      }

      el.indexBtn.addEventListener("click", () =>
        withLoading(el.indexBtn, "인덱싱...", async () => {
          setStatus("경로 문서 인덱싱 중...", "warn");
          try {
            const paths = el.paths.value
              .split("\n")
              .map((v) => v.trim())
              .filter(Boolean);
            if (!paths.length) {
              setStatus("경로를 1개 이상 입력하세요. 또는 샘플 채우기를 누르세요.", "warn");
              return;
            }
            const data = await callApi("/api/index", "POST", { paths });
            renderIndexResult(data);
            setStatus("인덱싱 완료", "ok");
          } catch (error) {
            renderError(error);
            setStatus("인덱싱 실패", "bad");
          }
        }),
      );

      el.samplePathsBtn.addEventListener("click", () => {
        el.paths.value = "docs/sample-api.md\ndocs/sample-oncall.md";
        setStatus("샘플 경로를 채웠습니다.", "ok");
      });

      el.uploadIndexBtn.addEventListener("click", () =>
        withLoading(el.uploadIndexBtn, "업로드...", async () => {
          const files = el.files.files ? Array.from(el.files.files) : [];
          if (!files.length) {
            setStatus("먼저 파일을 선택하세요.", "warn");
            return;
          }

          setStatus(`파일 ${files.length}개 인덱싱 중...`, "warn");
          try {
            const payloadFiles = await Promise.all(
              files.map(async (file) => {
                const buffer = await file.arrayBuffer();
                return {
                  source: file.name,
                  content_base64: arrayBufferToBase64(buffer),
                };
              }),
            );
            const data = await callApi("/api/index-upload", "POST", { files: payloadFiles });
            renderIndexResult(data);
            setStatus("업로드 인덱싱 완료", "ok");
          } catch (error) {
            renderError(error);
            setStatus("업로드 인덱싱 실패", "bad");
          }
        }),
      );

      el.sourcesBtn.addEventListener("click", () =>
        withLoading(el.sourcesBtn, "조회...", async () => {
          setStatus("소스 목록 조회 중...", "warn");
          try {
            const response = await fetch("/api/sources");
            const data = await response.json();
            renderSourcesResult(data);
            setStatus("조회 완료", "ok");
          } catch (error) {
            renderError(error);
            setStatus("조회 실패", "bad");
          }
        }),
      );

      el.askBtn.addEventListener("click", () =>
        withLoading(el.askBtn, "Streaming...", async () => {
          setStatus("스트리밍 답변 생성 중...", "warn");
          try {
            const question = el.question.value.trim();
            let streamMeta = null;
            let streamAnswer = "";

            await callAskStream(
              { question },
              {
                onMeta: (meta) => {
                  streamMeta = meta;
                  el.resultTitle.textContent = "답변 결과 (Streaming)";
                  el.chips.innerHTML = "";
                  appendChip("answer mode", meta?.answer_generation_mode || "-");
                  appendChip("retrieval", meta?.retrieval_mode || "-");
                  appendChip("citations", Array.isArray(meta?.citations) ? meta.citations.length : 0);

                  renderItems(
                    Array.isArray(meta?.citations)
                      ? meta.citations.map((c, idx) => ({
                          head: `[${idx + 1}] ${c.source} #${c.chunk_index} (score=${c.score})`,
                          body: c.snippet || "",
                        }))
                      : [],
                  );
                },
                onToken: (packet) => {
                  const token = packet?.token || "";
                  if (!token) return;
                  streamAnswer += token;
                  el.answer.textContent = streamAnswer;
                },
                onDone: (done) => {
                  const payload = done || {};
                  if (!streamAnswer && payload.answer) {
                    streamAnswer = payload.answer;
                    el.answer.textContent = streamAnswer;
                  }
                  if (payload.guidance) {
                    el.answer.textContent += `\n\n[안내] ${payload.guidance}`;
                  }
                  if (payload.latency_ms !== undefined) {
                    appendChip("latency", `${payload.latency_ms} ms`);
                  }

                  const raw = streamMeta && typeof streamMeta === "object"
                    ? { ...streamMeta, ...payload }
                    : payload;
                  el.rawJson.textContent = JSON.stringify(raw, null, 2);
                },
                onError: (packet) => {
                  const message = packet?.message || "stream error";
                  el.answer.textContent += `\n\n[stream error] ${message}`;
                },
              },
            );

            setStatus("답변 완료", "ok");
          } catch (error) {
            renderError(error);
            setStatus("답변 실패", "bad");
          }
        }),
      );

      el.askJsonBtn.addEventListener("click", () =>
        withLoading(el.askJsonBtn, "질의...", async () => {
          setStatus("JSON 답변 생성 중...", "warn");
          try {
            const data = await callApi("/api/ask", "POST", {
              question: el.question.value.trim(),
            });
            renderAskResult(data, "답변 결과 (JSON)");
            setStatus("답변 완료", "ok");
          } catch (error) {
            renderError(error);
            setStatus("답변 실패", "bad");
          }
        }),
      );

      el.searchBtn.addEventListener("click", () =>
        withLoading(el.searchBtn, "검색...", async () => {
          setStatus("검색 중...", "warn");
          try {
            const data = await callApi("/api/search", "POST", {
              query: el.question.value.trim(),
            });
            renderSearchResult(data);
            setStatus("검색 완료", "ok");
          } catch (error) {
            renderError(error);
            setStatus("검색 실패", "bad");
          }
        }),
      );

      el.summarizeBtn.addEventListener("click", () =>
        withLoading(el.summarizeBtn, "요약...", async () => {
          setStatus("전체 문서 요약 생성 중...", "warn");
          try {
            const instruction = el.question.value.trim();
            const data = await callApi("/api/summarize", "POST", {
              instruction: instruction || undefined,
              max_chunks: 120,
            });

            el.resultTitle.textContent = "전체 문서 요약";
            el.chips.innerHTML = "";
            appendChip("answer mode", data.answer_generation_mode || "-");
            appendChip("sources", data.source_count ?? 0);
            appendChip("chunks_used", data.chunk_count_used ?? 0);
            appendChip("latency", `${data.latency_ms || 0} ms`);
            appendChip("citations", Array.isArray(data.citations) ? data.citations.length : 0);

            el.answer.textContent = data.summary || "요약 없음";
            renderItems(
              Array.isArray(data.citations)
                ? data.citations.map((c, idx) => ({
                    head: `[${idx + 1}] ${c.source} #${c.chunk_index}`,
                    body: c.snippet || "",
                  }))
                : [],
            );
            el.rawJson.textContent = JSON.stringify(data, null, 2);
            setStatus("요약 완료", "ok");
          } catch (error) {
            renderError(error);
            setStatus("요약 실패", "bad");
          }
        }),
      );

      el.storageBtn.addEventListener("click", () =>
        withLoading(el.storageBtn, "조회...", async () => {
          setStatus("저장소 상태 조회 중...", "warn");
          try {
            const response = await fetch("/api/index/storage");
            const data = await response.json();
            renderStorageResult(data);
            setStatus("조회 완료", "ok");
          } catch (error) {
            renderError(error);
            setStatus("조회 실패", "bad");
          }
        }),
      );

      el.resetBtn.addEventListener("click", () =>
        withLoading(el.resetBtn, "초기화...", async () => {
          setStatus("인덱스 초기화 중...", "warn");
          try {
            const data = await callApi("/api/index/reset", "POST", {});
            el.resultTitle.textContent = "인덱스 초기화";
            el.chips.innerHTML = "";
            appendChip("cleared_sources", data.cleared_sources ?? 0);
            appendChip("cleared_chunks", data.cleared_chunks ?? 0);
            el.answer.textContent = "인덱스를 초기화했습니다.";
            el.items.innerHTML = "";
            el.rawJson.textContent = JSON.stringify(data, null, 2);
            setStatus("초기화 완료", "ok");
          } catch (error) {
            renderError(error);
            setStatus("초기화 실패", "bad");
          }
        }),
      );

      el.clearBtn.addEventListener("click", () => {
        resetOutput();
        setStatus("화면을 초기화했습니다.", "ok");
      });

      resetOutput();
    </script>
  </body>
</html>
